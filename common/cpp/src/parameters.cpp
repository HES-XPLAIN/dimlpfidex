#include "parameters.h"

/**
 * @brief Construct a new Parameters object containing all arguments passed by CLI.
 *
 * @param args Program arguments.
 * @param validParams Valid parameter codes.
 */
Parameters::Parameters(const std::vector<std::string> &args, const std::vector<ParameterCode> &validParams) {
  for (int p = 1; p < args.size(); p++) {
    std::string param = args[p];

    if (param.substr(0, 2) == "--") {
      param = param.substr(2);
      p++;

      if (p >= args.size()) {
        throw CommandArgumentException("Missing something at the end of the command.");
      }
      const std::string arg = args[p];

      if (p + 1 < args.size() && (args[p + 1].substr(0, 2) != "--" && args[p + 1].substr(0, 2) != "")) {
        throw CommandArgumentException("There is a parameter without -- (" + args[p + 1] + ").");
      }

      parseArg(param, arg, validParams);
    }
  }

  checkFilesIntegrity();
}

/**
 * @brief Construct a new Parameters object containing all arguments passed by JSON config file.
 *
 * @param jsonfile JSON config file name.
 * @param validParams Valid parameter codes.
 */
Parameters::Parameters(const std::string &jsonfile, const std::vector<ParameterCode> &validParams) {
  std::ifstream ifs;
  ifs.open(jsonfile);
  std::vector<std::string> args;

  if (!ifs.is_open() || ifs.fail()) {
    throw FileNotFoundError("JSON file to parse named '" + jsonfile + "' was not found, cannot proceed.");
  }

  Json jsonData = Json::parse(ifs);

  for (auto &item : jsonData.items()) {
    std::string value;

    if (item.value().is_string()) {
      value = static_cast<std::string>(item.value());
    } else {
      value = to_string(item.value());
    }

    parseArg(item.key(), value, validParams);
  }

  checkFilesIntegrity();
}

/**
 * @brief Ensures that every file/path is valid, every file related data should be added in this function.
 *
 */
void Parameters::checkFilesIntegrity() {
  // input files checks
  sanitizePath(TRAIN_DATA_FILE, true);
  sanitizePath(TRAIN_PRED_FILE, true);
  sanitizePath(TRAIN_CLASS_FILE, true);
  sanitizePath(TEST_DATA_FILE, true);
  sanitizePath(VALID_DATA_FILE, true);
  sanitizePath(VALID_CLASS_FILE, true);
  sanitizePath(TEST_PRED_FILE, true);
  sanitizePath(TEST_CLASS_FILE, true);
  sanitizePath(RULES_FILE, true);
  sanitizePath(GLOBAL_RULES_FILE, true);
  sanitizePath(ATTRIBUTES_FILE, true);
  sanitizePath(WEIGHTS_FILE, true);
  sanitizePath(NORMALIZATION_FILE, true);
  sanitizePath(HIDDEN_LAYERS_FILE, true);

  // handling output files checks (files that will be generated by the program)
  sanitizePath(TRAIN_PRED_OUTFILE, false);
  sanitizePath(TEST_PRED_OUTFILE, false);
  sanitizePath(VALID_PRED_OUTFILE, false);
  sanitizePath(WEIGHTS_OUTFILE, false);
  sanitizePath(HID_FILE, false);
  sanitizePath(STATS_FILE, false);
  sanitizePath(CONSOLE_FILE, false);
  sanitizePath(RULES_OUTFILE, false);
  sanitizePath(GLOBAL_RULES_OUTFILE, false);
  sanitizePath(EXPLANATION_FILE, false);
  sanitizePath(HIDDEN_LAYERS_OUTFILE, false);
}

/**
 * @brief Parses a given parameter name & its value in order to add it to the Parameter class.
 *
 * To add a new parameter you must follow this workflow:
 *    - Add a new element in the ParameterCode enum in Paramerters.h.
 *    - Add a new element in the unordered_map with the parameter literal name and its enum in Paramerters.h.
 *    - Adapt the code below to accept your new argument in the switch case.
 *
 * @param param Parameter name (ex: nb_threads, min_fidelity etc...).
 * @param arg Parameter's associated value.
 * @param validParams Vector of valid parameter codes.
 */
void Parameters::parseArg(const std::string &param, const std::string &arg, const std::vector<ParameterCode> &validParams) {
  ParameterCode option;
  auto it = parameterNames.find(param);
  if (it != parameterNames.end()) {
    option = it->second;
  } else {
    if (param == "json_config_file") {
      throw CommandArgumentException("Option " + param + " has to be the only option in the command if specified.");
    }
    throw CommandArgumentException("Illegal option : " + param);
  }

  // Check for invalid parameter
  if (std::find(validParams.begin(), validParams.end(), option) == validParams.end()) {
    throwInvalidParameter(option);
  }

  switch (option) {

    // Handle each parameter case

  case TRAIN_DATA_FILE:
    setString(TRAIN_DATA_FILE, arg);
    break;

  case TRAIN_PRED_FILE:
    setString(TRAIN_PRED_FILE, arg);
    break;

  case TRAIN_PRED_OUTFILE:
    setString(TRAIN_PRED_OUTFILE, arg);
    break;

  case TEST_DATA_FILE:
    setString(TEST_DATA_FILE, arg);
    break;

  case TEST_PRED_FILE:
    setString(TEST_PRED_FILE, arg);
    break;

  case TEST_PRED_OUTFILE:
    setString(TEST_PRED_OUTFILE, arg);
    break;

  case NB_ATTRIBUTES:
    setInt(NB_ATTRIBUTES, arg);
    break;

  case NB_CLASSES:
    setInt(NB_CLASSES, arg);
    break;

  case TRAIN_CLASS_FILE:
    setString(TRAIN_CLASS_FILE, arg);
    break;

  case TEST_CLASS_FILE:
    setString(TEST_CLASS_FILE, arg);
    break;

  case VALID_DATA_FILE:
    setString(VALID_DATA_FILE, arg);
    break;

  case VALID_CLASS_FILE:
    setString(VALID_CLASS_FILE, arg);
    break;

  case VALID_PRED_OUTFILE:
    setString(VALID_PRED_OUTFILE, arg);
    break;

  case WEIGHTS_FILE:
    setString(WEIGHTS_FILE, arg);
    break;

  case WEIGHTS_OUTFILE:
    setString(WEIGHTS_OUTFILE, arg);
    break;

  case HID_FILE:
    setString(HID_FILE, arg);
    break;

  case STATS_FILE:
    setString(STATS_FILE, arg);
    break;

  case RULES_FILE:
    setString(RULES_FILE, arg);
    break;

  case RULES_OUTFILE:
    setString(RULES_OUTFILE, arg);
    break;

  case NB_DIMLP_NETS:
    setInt(NB_DIMLP_NETS, arg);
    break;

  case NB_EX_PER_NET:
    setInt(NB_EX_PER_NET, arg);
    break;

  case NB_QUANT_LEVELS:
    setInt(NB_QUANT_LEVELS, arg);
    break;

  case NB_FIDEX_RULES:
    setInt(NB_FIDEX_RULES, arg);
    break;

  case GLOBAL_RULES_OUTFILE:
    setString(GLOBAL_RULES_OUTFILE, arg);
    break;

  case GLOBAL_RULES_FILE:
    setString(GLOBAL_RULES_FILE, arg);
    break;

  case EXPLANATION_FILE:
    setString(EXPLANATION_FILE, arg);
    break;

  case CONSOLE_FILE:
    setString(CONSOLE_FILE, arg);
    break;

  case ATTRIBUTES_FILE:
    setString(ATTRIBUTES_FILE, arg);
    break;

  case ROOT_FOLDER:
    checkPath(ROOT_FOLDER, arg); // root directory existence must be checked
    setString(ROOT_FOLDER, arg);
    break;

  case HEURISTIC:
    setInt(HEURISTIC, arg);
    break;

  case MAX_ITERATIONS:
    setInt(MAX_ITERATIONS, arg);
    break;

  case MIN_COVERING:
    setInt(MIN_COVERING, arg);
    break;

  case LEARNING_RATE:
    setFloat(LEARNING_RATE, arg);
    break;

  case MOMENTUM:
    setFloat(MOMENTUM, arg);
    break;

  case FLAT:
    setFloat(FLAT, arg);
    break;

  case ERROR_THRESH:
    setFloat(ERROR_THRESH, arg);
    break;

  case ACC_THRESH:
    setFloat(ACC_THRESH, arg);
    break;

  case ABS_ERROR_THRESH:
    setFloat(ABS_ERROR_THRESH, arg);
    break;

  case NB_EPOCHS:
    setInt(NB_EPOCHS, arg);
    break;

  case NB_EPOCHS_ERROR:
    setInt(NB_EPOCHS_ERROR, arg);
    break;

  case WITH_RULE_EXTRACTION:
    setBool(WITH_RULE_EXTRACTION, arg);
    break;

  case COVERING_STRATEGY:
    setBool(COVERING_STRATEGY, arg);
    break;

  case NB_THREADS:
    setInt(NB_THREADS, arg);
    break;

  case MIN_FIDELITY:
    setFloat(MIN_FIDELITY, arg);
    break;

  case LOWEST_MIN_FIDELITY:
    setFloat(LOWEST_MIN_FIDELITY, arg);
    break;

  case DROPOUT_DIM:
    setFloat(DROPOUT_DIM, arg);
    break;

  case DROPOUT_HYP:
    setFloat(DROPOUT_HYP, arg);
    break;

  case MAX_FAILED_ATTEMPTS:
    setInt(MAX_FAILED_ATTEMPTS, arg);
    break;

  case DECISION_THRESHOLD:
    setFloat(DECISION_THRESHOLD, arg);
    break;

  case POSITIVE_CLASS_INDEX:
    setInt(POSITIVE_CLASS_INDEX, arg);
    break;

  case NORMALIZATION_FILE:
    setString(NORMALIZATION_FILE, arg);
    break;

  case MUS:
    setDoubleVector(MUS, arg);
    break;

  case SIGMAS:
    setDoubleVector(SIGMAS, arg);
    break;

  case NORMALIZATION_INDICES:
    setIntVector(NORMALIZATION_INDICES, arg);
    break;

  case WITH_FIDEX:
    setBool(WITH_FIDEX, arg);
    break;

  case WITH_MINIMAL_VERSION:
    setBool(WITH_MINIMAL_VERSION, arg);
    break;

  case SEED:
    setInt(SEED, arg);
    break;

  case FIRST_HIDDEN_LAYER:
    setInt(FIRST_HIDDEN_LAYER, arg);
    break;

  case HIDDEN_LAYERS:
    setIntVector(HIDDEN_LAYERS, arg);
    break;

  case HIDDEN_LAYERS_OUTFILE:
    setString(HIDDEN_LAYERS_OUTFILE, arg);
    break;

  case HIDDEN_LAYERS_FILE:
    setString(HIDDEN_LAYERS_FILE, arg);
    break;

  default: // If we put another -X option
    throw CommandArgumentException("Illegal option : " + param);
  }
}

/**
 * @brief Sets an integer parameter from a string value.
 *
 * @param id The parameter code to set.
 * @param value The string value to convert and set as the integer parameter.
 * @throws CommandArgumentException if the parameter is already set or if the value is not a valid integer.
 */
void Parameters::setInt(ParameterCode id, const std::string &value) {
  if (isIntSet(id)) {
    throwAlreadySetArgumentException(id, value);
  }

  if (checkInt(value)) {
    _intParams[id] = stoi(value, nullptr);
  } else {
    throwInvalidDataTypeException(id, value, "integer");
  }
}

/**
 * @brief Sets an integer parameter.
 *
 * @param id The parameter code to set.
 * @param value The integer value to set.
 * @throws CommandArgumentException if the parameter is already set.
 */
void Parameters::setInt(ParameterCode id, int value) {
  if (isIntSet(id)) {
    throwAlreadySetArgumentException(id, std::to_string(value));
  }

  _intParams[id] = value;
}

/**
 * @brief Sets a float parameter from a string value.
 *
 * @param id The parameter code to set.
 * @param value The string value to convert and set as the float parameter.
 * @throws CommandArgumentException if the parameter is already set or if the value is not a valid float.
 */
void Parameters::setFloat(ParameterCode id, const std::string &value) {
  if (isFloatSet(id)) {
    throwAlreadySetArgumentException(id, value);
  }

  if (checkFloat(value)) {
    _floatParams[id] = stof(value, nullptr);
  } else {
    throwInvalidDataTypeException(id, value, "float");
  }
}

/**
 * @brief Sets a float parameter.
 *
 * @param id The parameter code to set.
 * @param value The float value to set.
 * @throws CommandArgumentException if the parameter is already set.
 */
void Parameters::setFloat(ParameterCode id, float value) {
  if (isFloatSet(id)) {
    throwAlreadySetArgumentException(id, std::to_string(value));
  }

  _floatParams[id] = value;
}

/**
 * @brief Checks if the specified path exists.
 *
 * @param id The parameter code associated with the path.
 * @param path The path to check.
 * @throws CommandArgumentException if the path does not exist.
 */
void Parameters::checkPath(ParameterCode id, const std::string &path) const {
  if (!exists(path)) {
    throwInvalidFileOrDirectory(id, path);
  }
}

/**
 * @brief Sets a double parameter from a string value.
 *
 * @param id The parameter code to set.
 * @param value The string value to convert and set as the double parameter.
 * @throws CommandArgumentException if the parameter is already set or if the value is not a valid double.
 */
void Parameters::setDouble(ParameterCode id, const std::string &value) {
  if (isDoubleSet(id)) {
    throwAlreadySetArgumentException(id, value);
  }

  if (checkFloat(value)) {
    _doubleParams[id] = stod(value, nullptr);
  } else {
    throwInvalidDataTypeException(id, value, "double");
  }
}

/**
 * @brief Sets a double parameter.
 *
 * @param id The parameter code to set.
 * @param value The double value to set.
 * @throws CommandArgumentException if the parameter is already set.
 */
void Parameters::setDouble(ParameterCode id, double value) {
  if (isDoubleSet(id)) {
    throwAlreadySetArgumentException(id, std::to_string(value));
  }

  _doubleParams[id] = value;
}

/**
 * @brief Sets a boolean parameter from a string value.
 *
 * @param id The parameter code to set.
 * @param value The string value to convert and set as the boolean parameter.
 * @throws CommandArgumentException if the parameter is already set or if the value is not a valid boolean.
 */
void Parameters::setBool(ParameterCode id, std::string value) {
  if (isBoolSet(id)) {
    throwAlreadySetArgumentException(id, value);
  }

  if (checkBool(value)) {
    std::transform(value.begin(), value.end(), value.begin(),
                   [](unsigned char c) { return std::tolower(c); });
    _boolParams[id] = (value == "true" || value == "1") ? true : false;
  } else {
    throw CommandArgumentException("Error : invalide type for parameter " + getParameterName(id) + ", boolean requested.");
  }
}

/**
 * @brief Sets a boolean parameter.
 *
 * @param id The parameter code to set.
 * @param value The boolean value to set.
 * @throws CommandArgumentException if the parameter is already set.
 */
void Parameters::setBool(ParameterCode id, bool value) {
  if (isBoolSet(id)) {
    throwAlreadySetArgumentException(id, std::to_string(value));
  }
  _boolParams[id] = value;
}

/**
 * @brief Sets a double vector parameter from a string value.
 *
 * @param id The parameter code to set.
 * @param value The string value to convert and set as the double vector parameter.
 * @throws CommandArgumentException if the parameter is already set or if the value is not a valid list of doubles.
 */
void Parameters::setDoubleVector(ParameterCode id, const std::string &value) {
  if (isDoubleVectorSet(id)) {
    throwAlreadySetArgumentException(id, value);
  }

  if (!checkList(value)) {
    throw CommandArgumentException("Error : invalide type for parameter " + getParameterName(id) + ", list in the form [a,b,...,c] without spaces requested, a,b,c are numbers. Received " + value + ".");
  }

  _doubleVectorParams[id] = getDoubleVectorFromString(value);
}

/**
 * @brief Sets a double vector parameter.
 *
 * @param id The parameter code to set.
 * @param value The vector of double values to set.
 */
void Parameters::setDoubleVector(ParameterCode id, const std::vector<double> &value) {
  if (isDoubleVectorSet(id)) {
    throwAlreadySetArgumentException(id, vectorToString(value));
  }
  _doubleVectorParams[id] = value;
}

/**
 * @brief Sets an integer vector parameter from a string value.
 *
 * @param id The parameter code to set.
 * @param value The string value to convert and set as the integer vector parameter.
 * @throws CommandArgumentException if the parameter is already set or if the value is not a valid list of integers.
 */
void Parameters::setIntVector(ParameterCode id, const std::string &value) {
  if (isIntVectorSet(id)) {
    throwAlreadySetArgumentException(id, value);
  }

  if (!checkList(value)) {
    throw CommandArgumentException("Error : invalide type for parameter " + getParameterName(id) + ", list in the form [a,b,...,c] without spaces requested, a,b,c are integers. Received " + value + ".");
  }
  _intVectorParams[id] = getIntVectorFromString(value);
}

/**
 * @brief Sets an integer vector parameter.
 *
 * @param id The parameter code to set.
 * @param value The vector of integer values to set.
 */
void Parameters::setIntVector(ParameterCode id, const std::vector<int> &value) {
  if (isIntVectorSet(id)) {
    throwAlreadySetArgumentException(id, vectorToString(value));
  }
  _intVectorParams[id] = value;
}

/**
 * @brief Sets a string parameter.
 *
 * @param id The parameter code to set.
 * @param value The string value to set.
 * @throws CommandArgumentException if the parameter is already set.
 */
void Parameters::setString(ParameterCode id, const std::string &value) {
  if (isStringSet(id)) {
    throwAlreadySetArgumentException(id, value);
  }
  _stringParams[id] = value;
}

/**
 * @brief Completes the path of a given parameter with the ROOT_FOLDER, also checks if the given parameter is not empty.
 *
 * @param id Parameter code to be completed.
 */
void Parameters::completePath(ParameterCode id) {
  // avoid error cases
  if (!isStringSet(id) || !isStringSet(ROOT_FOLDER) || id == ROOT_FOLDER) {
    return;
  }

  std::string fullPath;
  std::string target = getString(id);
  std::string separator = getOSSeparator();
  std::string root = isStringSet(ROOT_FOLDER) ? getString(ROOT_FOLDER) : "";

  if (target.empty() || target.back() == separator[0]) {
    throwInvalidFileOrDirectory(id, target);
  }

  if (root.empty() || !root.empty() && (root.back() == separator[0] || target.front() == separator[0])) {
    fullPath = root + target;
  } else {
    fullPath = root + separator + target;
  }

  _stringParams[id] = fullPath;
}

/**
 * @brief Handles every aspect of parameters that represents files.
 *
 * - Checks if a file exists if "shouldFileExist" is set to true.
 * - Appends the ROOT_FOLDER path to every file if ROOT_FOLDER is set.
 *
 * @param id Parameter code to be processed.
 * @param shouldFileExist Flag indicating whether the file should exist.
 */
void Parameters::sanitizePath(ParameterCode id, bool shouldFileExist) {
  // ignore if target is not set and avoid duplicating the root path for no reason
  if (!isStringSet(id) || id == ROOT_FOLDER) {
    return;
  }

  completePath(id);
  std::string fullPath = getString(id);

  if (shouldFileExist) {
    checkPath(id, fullPath);
  } else {
    checkPath(id, fullPath.substr(0, fullPath.find_last_of(getOSSeparator()) + 1));
  }
}

// public getters

/**
 * @brief Gets the integer value for the given parameter code.
 *
 * @param id The parameter code.
 * @return The integer value associated with the parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
int Parameters::getInt(ParameterCode id) {
  assertIntExists(id);
  return _intParams[id];
}

/**
 * @brief Gets the float value for the given parameter code.
 *
 * @param id The parameter code.
 * @return The float value associated with the parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
float Parameters::getFloat(ParameterCode id) {
  assertFloatExists(id);
  return _floatParams[id];
}

/**
 * @brief Gets the double value for the given parameter code.
 *
 * @param id The parameter code.
 * @return The double value associated with the parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
double Parameters::getDouble(ParameterCode id) {
  assertDoubleExists(id);
  return _doubleParams[id];
}

/**
 * @brief Gets the boolean value for the given parameter code.
 *
 * @param id The parameter code.
 * @return The boolean value associated with the parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
bool Parameters::getBool(ParameterCode id) {
  assertBoolExists(id);
  return _boolParams[id];
}

/**
 * @brief Gets the vector of double values for the given parameter code.
 *
 * @param id The parameter code.
 * @return The vector of double values associated with the parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
std::vector<double> Parameters::getDoubleVector(ParameterCode id) {
  assertDoubleVectorExists(id);
  return _doubleVectorParams[id];
}

/**
 * @brief Gets the vector of integer values for the given parameter code.
 *
 * @param id The parameter code.
 * @return The vector of integer values associated with the parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
std::vector<int> Parameters::getIntVector(ParameterCode id) {
  assertIntVectorExists(id);
  return _intVectorParams[id];
}

/**
 * @brief Gets the string value for the given parameter code.
 *
 * @param id The parameter code.
 * @return The string value associated with the parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
std::string Parameters::getString(ParameterCode id) {
  assertStringExists(id);
  return _stringParams[id];
}

/**
 * @brief Gets the architecture of hidden layers.
 *
 * @return The architecture of hidden layers.
 */
StringInt Parameters::getArch() {
  StringInt arch;
  if (isIntSet(FIRST_HIDDEN_LAYER)) {
    arch.Insert(getInt(FIRST_HIDDEN_LAYER));
  }
  if (isIntVectorSet(HIDDEN_LAYERS)) {
    for (int i = 0; i < getIntVector(HIDDEN_LAYERS).size(); i++) {
      arch.Insert(getIntVector(HIDDEN_LAYERS)[i]);
    }
  }
  return arch;
}

/**
 * @brief Gets the indices of the architecture of hidden layers.
 *
 * @return The indices of the architecture of hidden layers.
 */
StringInt Parameters::getArchInd() {
  StringInt archInd;
  if (isIntSet(FIRST_HIDDEN_LAYER)) {
    archInd.Insert(1);
  }
  if (isIntVectorSet(HIDDEN_LAYERS)) {
    for (int i = 0; i < getIntVector(HIDDEN_LAYERS).size(); i++) {
      archInd.Insert(i + 2);
    }
  }

  return archInd;
}

/**
 * @brief Gets the name of the parameter associated with the given parameter code.
 *
 * @param id The parameter code.
 * @return The name of the parameter.
 */
std::string Parameters::getParameterName(ParameterCode id) {
  for (const auto &pair : parameterNames) {
    if (pair.second == id) {
      return pair.first;
    }
  }
  return "unknown";
}

/**
 * @brief Checks if an integer parameter is set.
 *
 * @param id The parameter code.
 * @return True if the parameter is set, false otherwise.
 */
bool Parameters::isIntSet(ParameterCode id) {
  return _intParams.find(id) != _intParams.end();
}

/**
 * @brief Checks if a float parameter is set.
 *
 * @param id The parameter code.
 * @return True if the parameter is set, false otherwise.
 */
bool Parameters::isFloatSet(ParameterCode id) {
  return _floatParams.find(id) != _floatParams.end();
}

/**
 * @brief Checks if a double parameter is set.
 *
 * @param id The parameter code.
 * @return True if the parameter is set, false otherwise.
 */
bool Parameters::isDoubleSet(ParameterCode id) {
  return _doubleParams.find(id) != _doubleParams.end();
}

/**
 * @brief Checks if a boolean parameter is set.
 *
 * @param id The parameter code.
 * @return True if the parameter is set, false otherwise.
 */
bool Parameters::isBoolSet(ParameterCode id) {
  return _boolParams.find(id) != _boolParams.end();
}

/**
 * @brief Checks if a double vector parameter is set.
 *
 * @param id The parameter code.
 * @return True if the parameter is set, false otherwise.
 */
bool Parameters::isDoubleVectorSet(ParameterCode id) {
  return _doubleVectorParams.find(id) != _doubleVectorParams.end();
}

/**
 * @brief Checks if an integer vector parameter is set.
 *
 * @param id The parameter code.
 * @return True if the parameter is set, false otherwise.
 */
bool Parameters::isIntVectorSet(ParameterCode id) {
  return _intVectorParams.find(id) != _intVectorParams.end();
}

/**
 * @brief Checks if a string parameter is set.
 *
 * @param id The parameter code.
 * @return True if the parameter is set, false otherwise.
 */
bool Parameters::isStringSet(ParameterCode id) const {
  return _stringParams.find(id) != _stringParams.end();
}

// public assertions

/**
 * @brief Asserts that a string parameter is set.
 *
 * @param id The parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
void Parameters::assertStringExists(ParameterCode id) const {
  if (!isStringSet(id)) {
    throwArgumentNotFoundException(id);
  }
}

/**
 * @brief Asserts that an integer parameter is set.
 *
 * @param id The parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
void Parameters::assertIntExists(ParameterCode id) {
  if (!isIntSet(id)) {
    throwArgumentNotFoundException(id);
  }
}

/**
 * @brief Asserts that a float parameter is set.
 *
 * @param id The parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
void Parameters::assertFloatExists(ParameterCode id) {
  if (!isFloatSet(id)) {
    throwArgumentNotFoundException(id);
  }
}

/**
 * @brief Asserts that a double parameter is set.
 *
 * @param id The parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
void Parameters::assertDoubleExists(ParameterCode id) {
  if (!isDoubleSet(id)) {
    throwArgumentNotFoundException(id);
  }
}

/**
 * @brief Asserts that a boolean parameter is set.
 *
 * @param id The parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
void Parameters::assertBoolExists(ParameterCode id) {
  if (!isBoolSet(id)) {
    throwArgumentNotFoundException(id);
  }
}

/**
 * @brief Asserts that a double vector parameter is set.
 *
 * @param id The parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
void Parameters::assertDoubleVectorExists(ParameterCode id) {
  if (!isDoubleVectorSet(id)) {
    throwArgumentNotFoundException(id);
  }
}

/**
 * @brief Asserts that an integer vector parameter is set.
 *
 * @param id The parameter code.
 * @throws CommandArgumentException if the parameter is not set.
 */
void Parameters::assertIntVectorExists(ParameterCode id) {
  if (!isIntVectorSet(id)) {
    throwArgumentNotFoundException(id);
  }
}

// Default setters

/**
 * @brief Sets a default integer value for the given parameter code if not already set.
 *
 * @param id The parameter code.
 * @param defaultValue The default value to set.
 */
void Parameters::setDefaultInt(ParameterCode id, int defaultValue) {
  if (!isIntSet(id))
    setInt(id, defaultValue);
}

/**
 * @brief Sets a default float value for the given parameter code if not already set.
 *
 * @param id The parameter code.
 * @param defaultValue The default value to set.
 */
void Parameters::setDefaultFloat(ParameterCode id, float defaultValue) {
  if (!isFloatSet(id))
    setFloat(id, defaultValue);
}

/**
 * @brief Sets a default double value for the given parameter code if not already set.
 *
 * @param id The parameter code.
 * @param defaultValue The default value to set.
 */
void Parameters::setDefaultDouble(ParameterCode id, double defaultValue) {
  if (!isDoubleSet(id))
    setDouble(id, defaultValue);
}

/**
 * @brief Sets a default boolean value for the given parameter code if not already set.
 *
 * @param id The parameter code.
 * @param defaultValue The default value to set.
 */
void Parameters::setDefaultBool(ParameterCode id, bool defaultValue) {
  if (!isBoolSet(id))
    setBool(id, defaultValue);
}

/**
 * @brief Sets a default double vector value for the given parameter code if not already set.
 *
 * @param id The parameter code.
 * @param defaultValue The default value to set.
 */
void Parameters::setDefaultDoubleVector(ParameterCode id, const std::string &defaultValue) {
  if (!isDoubleVectorSet(id))
    setDoubleVector(id, defaultValue);
}

/**
 * @brief Sets a default integer vector value for the given parameter code if not already set.
 *
 * @param id The parameter code.
 * @param defaultValue The default value to set.
 */
void Parameters::setDefaultIntVector(ParameterCode id, const std::string &defaultValue) {
  if (!isIntVectorSet(id))
    setIntVector(id, defaultValue);
}

/**
 * @brief Sets a default string value for the given parameter code if not already set.
 *
 * @param id The parameter code.
 * @param defaultValue The default value to set.
 * @param withRoot Whether to prepend the ROOT_FOLDER to the default value.
 */
void Parameters::setDefaultString(ParameterCode id, const std::string &defaultValue, bool withRoot) {
  if (!isStringSet(id)) {
    std::string value = defaultValue;
    if (withRoot) {
      // define separator depending on OS
      std::string separator = getOSSeparator();
      value = getString(ROOT_FOLDER) + separator + defaultValue;
    }
    setString(id, value);
  }
}

/**
 * @brief Checks the attribute and class counts for validity.
 *
 * @throws CommandArgumentException if the number of attributes or classes is invalid.
 */
void Parameters::checkAttributeAndClassCounts() {

  if (getInt(NB_ATTRIBUTES) < 1) {
    throw CommandArgumentException("Error : Number of attributes must be strictly positive (>=1).");
  }

  if (getInt(NB_CLASSES) < 2) {
    throw CommandArgumentException("Error : Number of classes must be greater than 1.");
  }
}

/**
 * @brief Checks common parameters for validity.
 *
 * @throws CommandArgumentException if any common parameter is invalid.
 */
void Parameters::checkParametersCommon() {

  checkAttributeAndClassCounts();

  if (getInt(NB_QUANT_LEVELS) <= 2) {
    throw CommandArgumentException("Error : Number of stairs in staircase activation function must be greater than 2.");
  }
}

/**
 * @brief Checks Fidex-specific parameters for validity.
 *
 * @throws CommandArgumentException if any Fidex parameter is invalid.
 */
void Parameters::checkParametersFidex() {

  if (isStringSet(WEIGHTS_FILE) && isStringSet(RULES_FILE)) {
    throw CommandArgumentException("Error: Please choose only one among a weight file(--" + getParameterName(WEIGHTS_FILE) + ") and a rules input file(--" + getParameterName(RULES_FILE) + ")");
  }

  if (!isStringSet(WEIGHTS_FILE) && !isStringSet(RULES_FILE)) {
    throw CommandArgumentException("Error : A weight file(--" + getParameterName(WEIGHTS_FILE) + ") or a rules file(--" + getParameterName(RULES_FILE) + ") has to be given.");
  }

  if (getInt(MAX_ITERATIONS) < 1) {
    throw CommandArgumentException("Error : Maximum number of iterations must be strictly positive (>=1).");
  }

  if (getInt(MIN_COVERING) < 1) {
    throw CommandArgumentException("Error : Minimium covering must be strictly positive (>=1).");
  }

  if (getInt(MAX_FAILED_ATTEMPTS) < 0) {
    throw CommandArgumentException("Error : Maximum number of failed attempts has to be positive (>=0)");
  }

  if (getFloat(MIN_FIDELITY) < 0.0f || getFloat(MIN_FIDELITY) > 1.0f) {
    throw CommandArgumentException("Error : Minimum fidelity has to be between [0.0, 1.0]");
  }

  if (getFloat(LOWEST_MIN_FIDELITY) < 0.0f || getFloat(LOWEST_MIN_FIDELITY) > 1.0f) {
    throw CommandArgumentException("Error : Minimum fidelity has to be between [0.0, 1.0]");
  }

  if (getFloat(DROPOUT_DIM) < 0.0f || getFloat(DROPOUT_DIM) > 1.0f) {
    throw CommandArgumentException("Error : Dropout dim must be between [0.0, 1.0].");
  }

  if (getFloat(DROPOUT_HYP) < 0.0f || getFloat(DROPOUT_HYP) > 1.0f) {
    throw CommandArgumentException("Error : Dropout hyp must be between [0.0, 1.0].");
  }

  if (getInt(SEED) < 0) {
    throw CommandArgumentException("Error : random seed mus be positive (>=0).");
  }
}

/**
 * @brief Checks decision threshold and positive class index parameters for validity.
 *
 * @throws CommandArgumentException if any parameter is invalid.
 */
void Parameters::checkParametersDecisionThreshold() {

  if ((getFloat(DECISION_THRESHOLD) < 0.0f || getFloat(DECISION_THRESHOLD) > 1.0f) && getFloat(DECISION_THRESHOLD) != -1.0f) {
    throw CommandArgumentException("Error : Decision threshold must be beetween [0.0, 1.0].");
  }

  if (getInt(POSITIVE_CLASS_INDEX) < 0 && getInt(POSITIVE_CLASS_INDEX) != -1) {
    throw CommandArgumentException("Error : Positive class index must be positive (>=0)");
  }

  if (getInt(POSITIVE_CLASS_INDEX) >= getInt(NB_CLASSES)) {
    throw CommandArgumentException("Error : The index of positive class cannot be greater or equal to the number of classes (" + std::to_string(getInt(NB_CLASSES)) + ").");
  }

  if (getFloat(DECISION_THRESHOLD) != -1 && getInt(POSITIVE_CLASS_INDEX) == -1) {
    throw CommandArgumentException("Error : The positive class index has to be given with option --positive_class_index if the decision threshold is given (--decision_threshold)");
  }
}

/**
 * @brief Checks Dimlp training specific parameters for validity.
 *
 * @throws CommandArgumentException if any Dimlp training parameter is invalid.
 */
void Parameters::checkParametersDimlpTrn() {

  if (getFloat(LEARNING_RATE) <= 0) {
    throw CommandArgumentException("The learning parameter must be strictly positive (>0).");
  }

  if (getFloat(MOMENTUM) < 0) {
    throw CommandArgumentException("The momentum parameter must be positive (>=0).");
  }

  if (getFloat(FLAT) < 0) {
    throw CommandArgumentException("The flat parameter must be positive (>=0).");
  }

  if (getFloat(ERROR_THRESH) < 0 && getFloat(ERROR_THRESH) != -1111111111.0f) {
    throw CommandArgumentException("The error threshold must be positive (>=0).");
  }

  if ((getFloat(ACC_THRESH) <= 0 || getFloat(ACC_THRESH) > 1) && getFloat(ACC_THRESH) != 11111111111111.0f) {
    throw CommandArgumentException("The accuracy threshold must be between ]0,1].");
  }

  if (getFloat(ABS_ERROR_THRESH) < 0) {
    throw CommandArgumentException("The delta error parameter (ABS_ERROR_THRESH) must be positive (>=0, 0=not using delta).");
  }

  if (getInt(NB_EPOCHS) < 1) {
    throw CommandArgumentException("Error : Number of epochs must be strictly positive (>=1).");
  }

  if (getInt(NB_EPOCHS_ERROR) < 1) {
    throw CommandArgumentException("Error : Number of epochs to show errors must be strictly positive (>=1).");
  }

  if (isIntSet(FIRST_HIDDEN_LAYER) && (getInt(FIRST_HIDDEN_LAYER) < 1 || getInt(FIRST_HIDDEN_LAYER) % getInt(NB_ATTRIBUTES) != 0)) {
    throw CommandArgumentException("Error : Number of neurons in first hidden layer must be a multiple of the number of attributes (" + std::to_string(getInt(NB_ATTRIBUTES)) + ").");
  }

  if (isIntVectorSet(HIDDEN_LAYERS)) {
    for (int l : getIntVector(HIDDEN_LAYERS)) {
      if (l <= 0) {
        throw CommandArgumentException("Error : Number of neurons in each hidden layers must be strictly positive (>=1).");
      }
    }
  }

  if (getInt(SEED) < 0) {
    throw CommandArgumentException("Error : random seed mus be positive (>=0).");
  }
}

/**
 * @brief Checks normalization parameters for validity.
 *
 * @throws CommandArgumentException if any normalization parameter is invalid.
 */
void Parameters::checkParametersNormalization() {

  // Check denormalization parameters

  // If normalizationIndices were not specified, it's all attributes
  if (!isStringSet(NORMALIZATION_FILE) && !isIntVectorSet(NORMALIZATION_INDICES) && isDoubleVectorSet(MUS)) {
    std::vector<int> normalizationIndicesTemp;
    for (int i = 0; i < getInt(NB_ATTRIBUTES); ++i) {
      normalizationIndicesTemp.push_back(i);
    }
    setIntVector(NORMALIZATION_INDICES, normalizationIndicesTemp);
  }

  // Check if mus and sigmas are both given or both not
  if ((isDoubleVectorSet(MUS) || isDoubleVectorSet(SIGMAS)) &&
      !(isDoubleVectorSet(MUS) && isDoubleVectorSet(SIGMAS))) {
    throw CommandArgumentException("Error : One of Mus(--mus) and sigmas(--sigmas) is given but not the other.");
  }

  if (isStringSet(NORMALIZATION_FILE) && isDoubleVectorSet(MUS) || isStringSet(NORMALIZATION_FILE) && isIntVectorSet(NORMALIZATION_INDICES)) {
    throw CommandArgumentException("Error : normlization file (--normalization_file) and mus or normalizationIndices (--normalization_indices) are both given.");
  }

  // Mus, sigmas and normalizationIndices must have the same size and not be empty
  if (isDoubleVectorSet(MUS) && (getDoubleVector(MUS).size() != getDoubleVector(SIGMAS).size() || getDoubleVector(MUS).size() != getIntVector(NORMALIZATION_INDICES).size() || getDoubleVector(MUS).empty())) {
    throw CommandArgumentException("Error : mus (--mus), sigmas (--sigmas) and normalization indices (--normalization_indices) don't have the same size or are empty.");
  }

  // Check normalizationIndices
  if (isIntVectorSet(NORMALIZATION_INDICES)) {
    std::vector<int> tempVect = getIntVector(NORMALIZATION_INDICES);
    std::set<int> uniqueIndices(tempVect.begin(), tempVect.end());
    if (uniqueIndices.size() != getIntVector(NORMALIZATION_INDICES).size() ||
        *std::max_element(uniqueIndices.begin(), uniqueIndices.end()) >= getInt(NB_ATTRIBUTES) ||
        *std::min_element(uniqueIndices.begin(), uniqueIndices.end()) < 0) {
      throw CommandArgumentException("Error : parameter normalization indices (--normalization_indices) must be a list composed of integers between [0, nb_attributes-1(" + std::to_string(getInt(NB_ATTRIBUTES) - 1) + ")] without repeted elements.");
    }
  }
}

/**
 * @brief Sets the default number of quantization levels.
 */
void Parameters::setDefaultNbQuantLevels() {
  setDefaultInt(NB_QUANT_LEVELS, 50);
}

/**
 * @brief Sets the default values of Fidex parameters.
 */
void Parameters::setDefaultFidex() {
  setDefaultInt(MAX_ITERATIONS, 10);
  setDefaultInt(MIN_COVERING, 2);
  setDefaultInt(MAX_FAILED_ATTEMPTS, 30);
  setDefaultFloat(MIN_FIDELITY, 1.0);
  setDefaultFloat(LOWEST_MIN_FIDELITY, 0.75);
  setDefaultBool(COVERING_STRATEGY, true);
  setDefaultFloat(DROPOUT_DIM, 0.0f);
  setDefaultFloat(DROPOUT_HYP, 0.0f);
  setDefaultFloat(HI_KNOT, 5.0f);
  setDefaultInt(SEED, 0);
}

/**
 * @brief Sets the default values of decision threshold and positive class index parameters.
 */
void Parameters::setDefaultDecisionThreshold() {
  setDefaultFloat(DECISION_THRESHOLD, -1.0f);
  setDefaultInt(POSITIVE_CLASS_INDEX, -1);
}

/**
 * @brief Sets the default values of Dimlp training parameters.
 */
void Parameters::setDefaultDimlpTrn() {
  setDefaultFloat(LEARNING_RATE, 0.1f);
  setDefaultFloat(MOMENTUM, 0.6f);
  setDefaultFloat(FLAT, 0.01f);
  setDefaultFloat(ERROR_THRESH, -1111111111.0f);
  setDefaultFloat(ACC_THRESH, 11111111111111.0f);
  setDefaultFloat(ABS_ERROR_THRESH, 0.0f);
  setDefaultInt(NB_EPOCHS_ERROR, 10);
  setDefaultInt(NB_EPOCHS, 1500);
  setDefaultBool(WITH_RULE_EXTRACTION, false);
  setDefaultString(HIDDEN_LAYERS_OUTFILE, "hidden_layers.out", true);
  setDefaultInt(SEED, 0);
}

/**
 * @brief Write the configuration of hidden layers to a file.
 */
void Parameters::writeHiddenLayersFile() {
  std::string fileName = getString(HIDDEN_LAYERS_OUTFILE);
  std::ofstream hidFile(fileName, std::ofstream::out);

  if (!hidFile.is_open()) {
    throw CannotOpenFileError("Erroe : Impossible to open file : " + fileName);
  }

  if (hidFile.fail()) {
    throw InternalError("Error during the writing of file : " + fileName);
  }

  if (isIntSet(FIRST_HIDDEN_LAYER)) {
    hidFile << "1 " << getInt(FIRST_HIDDEN_LAYER);
  } else {
    hidFile << "1 " << getInt(NB_ATTRIBUTES);
  }

  hidFile << "\n";

  if (isIntVectorSet(HIDDEN_LAYERS)) {
    for (int i = 0; i < getIntVector(HIDDEN_LAYERS).size(); i++) {
      hidFile << std::to_string(i + 2) << " " << std::to_string(getIntVector(HIDDEN_LAYERS)[i]) << "\n";
    }
  }

  hidFile.close();
  std::cout << fileName << ": Written." << std::endl;
}

/**
 * @brief Reads, checks, and stores the hidden layers configuration file.
 *
 * Format of the file:
 * The file format should include pairs of strictly positive integers on each line, where the first integer represents
 * the layer's ID (starting at 1 and incrementing by 1 for each layer) and the second integer represents the number of
 * neurons in that layer. The first layer's number of neurons must be a multiple of the number of attributes.
 *
 * @param arch A reference to a StringInt object where the neuron counts of each layer will be stored.
 * @param archInd A reference to a StringInt object where the IDs of each layer will be stored.
 */
void Parameters::readHiddenLayersFile(StringInt &arch, StringInt &archInd) {

  std::string fileName = getString(HIDDEN_LAYERS_FILE);
  std::fstream hidFile;

  hidFile.open(fileName, std::ios::in); // Read file
  if (hidFile.fail()) {
    throw FileNotFoundError("Error : file " + fileName + " not found.");
  }

  std::regex lineFormat(R"(^\s*(\d+)\s+(\d+)\s*$)");
  std::smatch match;
  std::string line;
  int idLayer = 1;
  while (getline(hidFile, line)) {
    if (!checkStringEmpty(line)) {
      if (std::regex_match(line, match, lineFormat)) {
        int id = std::stoi(match[1].str());
        if (id == idLayer) {
          archInd.Insert(id);
        } else {
          throw FileContentError("Error in file " + fileName + " : id of layer not correct, it must start at 1 and increment by 1 for each layer, received " + std::to_string(id) + ".");
        }
        int value = std::stoi(match[2].str());
        if (value > 0) {
          arch.Insert(value);
        } else {
          throw FileContentError("Error in file " + fileName + " : the number of neurons in each layer must be strictly positive, received " + std::to_string(value) + ".");
        }
        if (id == 1 && value % getInt(NB_ATTRIBUTES) != 0) {
          throw FileContentError("Error : File " + fileName + " : the number of neurons in the first layer (" + std::to_string(value) + ") has to be a multiple of the number of attributes (" + std::to_string(getInt(NB_ATTRIBUTES)) + ").");
        }
      } else {
        throw FileContentError("Error : File " + fileName + " is not on good format. Each layer id and value must be strictly positive numbers separated by a space, each layer on a new line. Index starts at 1.");
      }
      idLayer += 1;
    }
  }
  if (idLayer == 1) {
    throw FileContentError("Error : File " + fileName + " has no layer data.");
  }
}
