
.. _program_listing_file__home_runner_work_dimlpfidex_dimlpfidex_common_cpp_src_rule.h:

Program Listing for File rule.h
===============================

|exhale_lsh| :ref:`Return to documentation for file <file__home_runner_work_dimlpfidex_dimlpfidex_common_cpp_src_rule.h>` (``/home/runner/work/dimlpfidex/dimlpfidex/common/cpp/src/rule.h``)

.. |exhale_lsh| unicode:: U+021B0 .. UPWARDS ARROW WITH TIP LEFTWARDS

.. code-block:: cpp

   #ifndef RULE_H
   #define RULE_H
   // Find better way to include this
   #include "../../../json/single_include/nlohmann/json.hpp"
   #include "antecedent.h"
   #include "checkFun.h"
   #include "dataSet.h"
   #include "parameters.h"
   #include <algorithm>
   #include <cmath>
   #include <fstream>
   #include <iostream>
   #include <string>
   #include <vector>
   
   using Json = nlohmann::json;
   
   class Rule {
   private:
     std::vector<Antecedent> antecedents; 
     std::vector<int> coveredSamples;     
     int outputClass = -1;                
     int coveringSize = -1;               
     double fidelity = -1;                
     double accuracy = -1;                
     double confidence = -1;              
   
     // define to ease JSON lib use
     NLOHMANN_DEFINE_TYPE_INTRUSIVE(Rule, antecedents, coveredSamples, outputClass, coveringSize, fidelity, accuracy, confidence)
   
   public:
     Rule() = default;
   
     Rule(const std::vector<Antecedent> &antecedents,
          const std::vector<int> &coveredSamples,
          int out_class,
          double fidelity,
          double accuracy,
          double confidence);
   
     // SETTERS
   
     void setOutputClass(int value) { outputClass = value; }
   
     void setCoveringSize(int value) { coveringSize = value; }
   
     void setFidelity(double value) { fidelity = value; }
   
     void setAccuracy(double value) { accuracy = value; }
   
     void setConfidence(double value) { confidence = value; }
   
     void setAntecedents(const std::vector<Antecedent> &values) { antecedents = values; }
   
     void setCoveredSamples(const std::vector<int> &values) {
       coveredSamples = values;
       coveringSize = static_cast<int>(values.size());
     }
   
     // GETTERS
   
     std::vector<Antecedent> getAntecedents() const { return antecedents; }
   
     int getNbAntecedents() const { return static_cast<int>(antecedents.size()); }
   
     std::vector<int> getCoveredSamples() const { return coveredSamples; }
   
     int getCoveringSize() const { return coveringSize; }
   
     int getOutputClass() const { return outputClass; }
   
     double getFidelity() const { return fidelity; }
   
     double getAccuracy() const { return accuracy; }
   
     double getConfidence() const { return confidence; }
   
     // UTILITIES
   
     void addAntecedent(Antecedent value) { antecedents.push_back(value); };
   
     void addCoveredSample(int value) {
       coveredSamples.push_back(value);
       coveringSize += 1;
     };
   
     std::string toString(const std::vector<std::string> &attributes, const std::vector<std::string> &classes) const;
   
     bool isEqual(const Rule &other) const;
   
     static std::vector<Rule> fromJsonFile(const std::string &filename, float &decisionThreshold, int &positiveClassIndex);
   
     static void toJsonFile(const std::string &filename, const std::vector<Rule> &rules, float threshold, int positiveIndex);
   };
   
   // OPERATOR OVERLOAD TO EASE PRINTING PURPOSES
   
   inline std::ostream &operator<<(std::ostream &stream, const Rule &rule) {
     for (Antecedent a : rule.getAntecedents())
       stream << a;
     stream << std::endl;
     stream << "   #Antecedents: " << std::to_string(rule.getAntecedents().size()) << std::endl
            << "   #Covered samples: " << std::to_string(rule.getCoveredSamples().size()) << std::endl
            << "   Confidence: " << std::to_string(rule.getConfidence()) << std::endl
            << "   Accuracy:   " << std::to_string(rule.getAccuracy()) << std::endl
            << "   Covering:   " << std::to_string(rule.getCoveredSamples().size()) << std::endl;
   
     return stream;
   }
   
   inline bool operator==(const Rule &r1, const Rule &r2) {
     return r1.isEqual(r2);
   }
   
   inline bool operator!=(const Rule &r1, const Rule &r2) {
     return !r1.isEqual(r2);
   }
   
   // FUNCTIONS TO HANDLE RULES PATTERNS AND FILES
   
   std::string generateRegexSmallerPositive(int maxNumber);
   
   std::string getAntStrPatternWithAttrIds(int nbAttributes);
   
   std::string getAntStrPatternWithAttrNames();
   
   std::string getStrPatternWithClassIds(int nbClasses);
   
   std::string getStrPatternWithClassNames();
   
   std::vector<bool> getRulesPatternsFromRuleFile(const std::string &rulesFile, const DataSetFid &dataset, bool withClasses = true);
   
   bool stringToRule(Rule &rule, const std::string &str, const std::regex &attributePattern, const std::regex &classPattern, bool withAttributeNames, bool withClassNames, DataSetFid &dataset);
   
   void getRules(std::vector<Rule> &rules, const std::string &rulesFile, DataSetFid &dataset, float &decisionThreshold, int &positiveClassIndex);
   
   std::tuple<double, double> writeRulesFile(const std::string &filename, const std::vector<Rule> &rules, const std::vector<std::string> &attributeNames,
                                             const std::vector<std::string> &classNames, float threshold, int positiveIndex);
   
   void getActivatedRules(std::vector<int> &activatedRules, std::vector<Rule> &rules, std::vector<double> &testValues);
   
   void getThresholdFromRulesFile(const std::string &filePath, float &decisionThreshold, int &positiveClassIndex);
   
   #endif // RULE_H
